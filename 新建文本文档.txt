3月21日
	已经实现了接收非阻塞udp，并移植到linux上，实现了捕获新接入的充电桩ip，测试不丢包

3月21日
	已经实现了创建UDP线程，在线程中存储新接入的充电桩的ip和端口，并把采集数据存储在txt中。

3月24日
	实现tcp客户端连接超时，接收超时。

3月25日
	实现udp类的封装，实现UdpThread类的封装，并移植到linux中，实现了tcp类的封装
3月26日
	实现tcpthread类的封装，并成功移植到linux下，并修改了多个线程使用cout打印存在乱码的问题。
	从现在开始，以后所有的代码都只支持linux，因为linux的读写锁和windows不一样，实现了线程间通信（全局变量）和同步（读写锁）。
3月28日
	实现connect精确的辨别服务端的状态，之前的代码有个bug，就是使用connect连接服务器的
时候，认为只要select的监控句柄变为可写就行了，其实不然，细节的因素还是很多的，所以要判断，
只要监控的句柄有可读或则可写的，那么就再发送connect，通过返回值就能判断服务端的实际状态。，
实现断线重连。

3月30日
	尝试实现离线存储转发，限定每次读取离线备份的大小，一次最多1472字节，读取完当次，保存上次最终读到的地址，下次从相同地址上进行，如果确定当次已经
完全读完，那么清空文档，这样就能很好的做离线存储，能防止数据的丢失。但是这版本其实有一个潜在的bug，虽然这个项目中不会遇到，就是判断
getline的eof()函数有时候并不能正常工作。https://blog.csdn.net/wmdcstdio/article/details/53395379 ，我调试的时候遇到了，其实还有
个bug，就是使用getline函数读取文本中字符串，如果一行的长度大于设置的大小，那么会造成错误，函数不会接着读取后面的数据，有解决方案
，http://www.cnblogs.com/klzwj1988/archive/2010/07/31/1789268.html，不过这里我打算直接清空txt，因为这时候命令显然是错的，充电桩
程序错误了。
	
3月31日
	解决了tcp文件读取的bug，单行超长直接打印警告，然后清空txt。
	还测试了定时器，由于signal函数的参数不能是类成员函数，所以很麻烦，不能使用信号了，只能通过轮询时间差来做定时。
	把udp的client网络地址缓存由数组改成vector，适应客户端的数量，更加安全，测试成功。
	

	这个版本只剩下实现udp的解析转发了，但是项目需要，协议要按照二进制的形式，所以解析都得变。

4月1日：
	udp的二进制存储没问题。将字符模式改成16进制的最大的问题是，ox00对应的字符是空，所有对字符的操作遇到这个空字符就会停止！！！！包括strlen，和文件操
作获取文件大小都会失败，文件保存也得使用二进制方式。
	tcp二进制发送和离线转发机制都完成，这个离线备份方案写的比之前灵活，这次我是先判断文档总的字节数，做判断，如果大于tcp一次要发送的数据，那么我就
发送1460字节，并保存此次读取后的get指针，要是能够一次发送完，就发送完，核心是每次打开文件就获取总文件和get指针的位置，作差值，和1746比较，如果差值小于
1746，就读完，设置读完标准，然后把标志都重置。
	
4月2日：
	tcp的离线存储修改完毕，udp线程查询tcp缓存文件并解析uid成功，发送给指点的充电桩ip和端口（但当前默认的是整个tcp文件中只有一条命令）。




下一版：
	等着服务端的命令协议定好，再详细完善tcp数据备份的解析。


4月12日：
	经过一系列问题，程序成功移植到板子上，主要是编译器改用arm-linux-g++，加-static，然后线程代码的makefile加上一个参数。全部搞通，另外改了一个小bug，
就是如果基站板连接本地的主机的时候，可能马上就返回失败，select不怎么超时，结果就是快速循环连接，导致程序死
机状态，改法：在相应地方加上sleep(3)。


	下一版：完善tcp数据协议备份的解析。